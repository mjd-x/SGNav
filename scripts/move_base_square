#!/usr/bin/env python3
import rospy
import math

import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalStatus
from geometry_msgs.msg import Pose, Point, Quaternion
from tf.transformations import quaternion_from_euler, euler_from_quaternion
from visualization_msgs.msg import Marker

import os
import numpy as np
# import pyzed.sl as sl
from sensor_msgs import Image
import cv2
from cv_bridge import CvBridge
import sqlite3
import datetime

class MoveBaseSquare():

    def __init__(self):
        # inicia el nodo
        rospy.init_node('move_base_square')
        # toma largo del cuadrado fijado en el launch
        square_length = rospy.get_param('move_base_square/sq_length')
        # angulos de las esquinas del cuadrado
        yaweulerangles_seq = [90,180,270,0]
        # lista de quaternions (orientacion) para las pose
        quat_seq = list()
        # lista de pose
        self.pose_seq = list()
        # contador para ver cuantas poses ya mando, y si faltan
        self.goal_cnt = 0

        for yawangle in yaweulerangles_seq:
            # * -> unpacker, extrae valor de la lista
            # crea y agrega a la lista de quaternions los angulos
            quat_seq.append(Quaternion(*(quaternion_from_euler(0, 0, yawangle*math.pi/180, axes='sxyz'))))

        # genera lista de puntos cada 1 metro recorriendo el cuadrado
        # cambiando la orientacion cuando llega a la esquina
        for i in range(1, square_length+1):
            self.pose_seq.append(Pose(Point(i, 0, 0), quat_seq[0]))

        for i in range(1, square_length+1):
            self.pose_seq.append(Pose(Point(square_length, i, 0), quat_seq[1]))

        # en los que decrece tomo el num 0, sino queda un punto duplicado y falta el del 0
        for i in reversed(range(0, square_length)):
            self.pose_seq.append(Pose(Point(i, square_length, 0), quat_seq[2]))

        for i in reversed(range(0, square_length)):
            self.pose_seq.append(Pose(Point(0, i, 0), quat_seq[3]))

        # Inicializa los markers para rviz (lista y cosas esteticas)
        rospy.loginfo("Setting up rviz markers...")
        self.init_markers()
        
        # agrega los puntos a la lista de markers        
        for pose in self.pose_seq:           
            p = Point()
            p = pose.position
            rospy.loginfo(str(p))
            self.markers.points.append(p)

        # inicializa la camara
        self.init_camera()

        # incializa db
        self.init_database()

        # Crea action client: primer arg es el namespace de los topics (namespace/goal, namespace/feedback, etc...)
        # MoveBaseAction es el tipo de accion que intercambian a traves de los topics
        self.client = actionlib.SimpleActionClient('move_base_simple',MoveBaseAction)
        rospy.loginfo("Waiting for move_base action server...")
        wait = self.client.wait_for_server()
        if not wait:
            rospy.logerr("Action server not available!")
            rospy.signal_shutdown("Action server not available!")
            return
        rospy.loginfo("Connected to move base server")
        rospy.loginfo("Starting goals achievements ...")
        self.movebase_client()
        
    # SimpleActionClient tiene 3 estados: 
    # activo (el servidor esta procesando el goal actual)
    # pendiente (los goals que todavia no se procesaron, estan "en cola")
    # terminado (ya se procesaron todos los goals)

    def active_cb(self):
        rospy.loginfo("Goal pose "+str(self.goal_cnt+1)+" is now being processed by the Action Server...")

    def feedback_cb(self, feedback):
        #rospy.loginfo("Feedback for goal pose "+str(self.goal_cnt+1)+" received")
        pass

    def done_cb(self, status, result):
        # si termino de procesar un goal, paso al siguiente
        self.goal_cnt += 1
        # Reference for terminal status values: http://docs.ros.org/diamondback/api/actionlib_msgs/html/msg/GoalStatus.html
        # Verifica el estado en la response
        if status == 2:
            # PREEMPTED: received a cancel request after it started executing and has since completed its execution
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" received a cancel request after it started executing, completed execution!")

        if status == 3:
            # SUCCEEDED
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" reached") 
            # Si llego al goal, pasa al siguiente
            self.send_next_goal()

        if status == 4:
            # ABORTED: aborted during execution by the action server due to some failure
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" was aborted by the Action Server")
            self.current_pose = self.pose_seq[self.goal_cnt-1]
            self.take_image = True
            # self.get_image() # guarda foto del obstaculo, pasa data de la pose
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" aborted, trying next goal")
            self.send_next_goal()

        if status == 5:
            # REJECTED: rejected by the action server without being processed, was unattainable or invalid
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" has been rejected by the Action Server")
            self.current_pose = self.pose_seq[self.goal_cnt-1]
            self.take_image = True
            # self.get_image(self.pose_seq[self.goal_cnt-1]) # guarda foto del obstaculo, pasa data de la pose
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" rejected, trying next goal")
            self.send_next_goal()

        if status == 8:
            # RECALLED: goal received a cancel request before it started executing and was successfully cancelled
            rospy.loginfo("Goal pose "+str(self.goal_cnt)+" received a cancel request before it started executing, successfully cancelled!")

    def send_next_goal(self):
        # Verifica si ya proceso todos los goals, si faltan pasa al siguiente, sino termina
        if self.goal_cnt < len(self.pose_seq):
            self.marker_pub.publish(self.markers)
            next_goal = MoveBaseGoal()
            next_goal.target_pose.header.frame_id = "map"
            next_goal.target_pose.header.stamp = rospy.Time.now()
            next_goal.target_pose.pose = self.pose_seq[self.goal_cnt]
            rospy.loginfo("Sending goal pose "+str(self.goal_cnt+1)+" to Action Server")
            rospy.loginfo(str(self.pose_seq[self.goal_cnt]))
            self.client.send_goal(next_goal, self.done_cb, self.active_cb, self.feedback_cb) 
        else:
            rospy.loginfo("Final goal pose reached!")
            self.zed.close()
            rospy.signal_shutdown("Final goal pose reached!")
            return

    def init_markers(self):
        # cargar markers para rviz
        marker_scale = 0.2
        marker_lifetime = 0 # no se van
        marker_ns = 'points'
        marker_id = 0
        marker_color = {'r': 1.0, 'g': 0.7, 'b': 1.0, 'a': 1.0}
        
        # define el publisher de los markers, nombre y tipo de dato que publica
        self.marker_pub = rospy.Publisher('visualization_marker', Marker, queue_size=100)
        
        # inicializa la lista de markers
        self.markers = Marker()
        self.markers.ns = marker_ns
        self.markers.id = marker_id
        # A sphere list is a list of spheres with all the same properties except their positions. Faster rendering
        # http://wiki.ros.org/rviz/DisplayTypes/Marker#Sphere_List_.28SPHERE_LIST.3D7.29    
        self.markers.type = Marker.SPHERE_LIST
        self.markers.action = Marker.ADD
        self.markers.lifetime = rospy.Duration(marker_lifetime)
        self.markers.scale.x = marker_scale
        self.markers.scale.y = marker_scale
        self.markers.color.r = marker_color['r']
        self.markers.color.g = marker_color['g']
        self.markers.color.b = marker_color['b']
        self.markers.color.a = marker_color['a']
        
        self.markers.header.frame_id = 'map'
        self.markers.header.stamp = rospy.Time.now()
        self.markers.points = list()

    def init_database(self):
        # crea archivo y conecta
        try:
            self.database_path = os.path.expanduser("~") + "/robot.db"
            rospy.loginfo("Creating database... (" + self.database_path + ")")
            conn = sqlite3.connect(self.database_path)
            rospy.loginfo("Database created")

            # crea tabla
            sql = """CREATE TABLE IF NOT EXISTS obstacle (
                        id integer PRIMARY KEY NOT NULL,
                        filename text NOT NULL,
                        timestamp text NOT NULL,
                        x integer NOT NULL,
                        y integer NOT NULL,
                        z integer NOT NULL,
                        angle integer NOT NULL
                    );"""

            try:
                conn.cursor().execute(sql)
                rospy.loginfo("Table created")

                conn.commit()
                conn.close()
            except sqlite3.Error as e:
                rospy.loginfo(e)

        except sqlite3.Error as e:
            rospy.loginfo(e)

    def init_camera(self):
        # # crear objeto camara
        # self.zed = sl.Camera()

        # # parametros de configuracion, carga los default
        # init_params = sl.InitParameters()
        # init_params.camera_resolution = sl.RESOLUTION.HD1080
        # init_params.camera_fps = 30

        # # abre la camara
        # rospy.loginfo("Opening camera...")
        # err = self.zed.open(init_params)
        # if err != sl.ERROR_CODE.SUCCESS:
        #     rospy.loginfo("Failed to open camera")

        # # fijar parametros de runtime despues de abrir la camara
        # self.runtime = sl.RuntimeParameters()
        # self.runtime.sensing_mode = sl.SENSING_MODE.STANDARD

        # # preparar imagen y matrices
        # self.image_size = self.zed.get_camera_information().camera_resolution
        # self.image_left = sl.Mat(self.image_size.width, self.image_size.height, sl.MAT_TYPE.U8_C4)
        # self.image_right = sl.Mat(self.image_size.width, self.image_size.height, sl.MAT_TYPE.U8_C4)

        self.camera_list = rospy.Subscriber('/camera/color/image_raw', callback=self.get_image)
        rospy.loginfo("Subscribed to camera topic")
        self.take_image = False

        self.bridge = CvBridge()

        rospy.loginfo("Creating images directory...")
        # crear dir donde guarda las img
        self.image_path = os.path.join(os.path.expanduser("~"), 'robot_images')

        # si ya existe, no lo crea de vuelta
        try:
            os.mkdir(self.image_path)
            rospy.loginfo("Directory created (" + self.image_path + ")")
        except FileExistsError:
            rospy.loginfo("Images directory already exists (" + self.image_path + ")")

    def get_image(self, message):
        # # guardar imagen (sbs, juntar las de las dos camaras)
        # if (self.zed.grab(self.runtime) == sl.ERROR_CODE.SUCCESS) :
        #     # si devuelve success, se capturo la imagen
        #     # imagen camara izq
        #     self.zed.retrieve_image(self.image_left, sl.VIEW.LEFT, sl.MEM.CPU, self.image_size)
        #     # convierte en matriz numpy para que pueda leer opencv
        #     image_cv_left = self.image_left.get_data()

        #     # imagen camara derecha
        #     self.zed.retrieve_image(self.image_right, sl.VIEW.RIGHT, sl.MEM.CPU, self.image_size)
        #     image_cv_right = self.image_right.get_data()
            
        #     # timestamp de la imagen
        #     timestamp = self.zed.get_current_timestamp(sl.TIME_REFERENCE.IMAGE) # Get the timestamp of the image
        #     rospy.loginfo("Obstacle image taken")

        #     # junta las dos imagenes
        #     sbs_image = np.concatenate((image_cv_left, image_cv_right), axis=1)
    
        if self.take_image is True:
            rospy.loginfo("Getting obstacle image...")
            image = message.data
            image_cv = self.bridge.imgmsg_to_cv2(image)

            # guardar imagen como png
            timestamp = datetime.datetime.now().strftime("%Y/%m/%d_%H-%m-%S")
            filename = self.image_path + "/image_" + timestamp + ".png"
            cv2.imwrite(filename, image_cv)
            rospy.loginfo("Saved image: " + filename)

            rospy.loginfo("Getting pose data...")
            # tomar datos para db
            p = Point()
            p = self.current_pose.position
            x = p.x
            y = p.y
            z = p.z

            q = Quaternion()
            q = self.current_pose.orientation
            euler = euler_from_quaternion(q)
            angle = euler[2]/(math.pi*180)

            # guardar la imagen en la db con los datos
            self.save_image(filename, timestamp, x, y, z, angle)
            rospy.loginfo("Saved to database")

            self.take_image = False
            

    def save_image(self, filename, timestamp, x, y, z, angle):
        # crea conexion
        try:
            
            conn = sqlite3.connect(self.database_path)
            print("db created")
            
            sql = """INSERT INTO obstacle(filename, timestamp, x, y, z, angle)
                        VALUES(""" + str(filename) + "," + str(timestamp) + "," + str(x) + "," + str(y) + "," + str(z) + "," + str(angle) + """
                    );"""
            try:
                conn.cursor().execute(sql)
                conn.commit()
            except sqlite3.Error as e:
                print(e)

            conn.close()

        except sqlite3.Error as e:
            print.info(e)

    def movebase_client(self):
        # publica los markers al topic para rviz
        self.marker_pub.publish(self.markers)
        # Crea goal y lo manda al servidor
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.header.stamp = rospy.Time.now() 
        goal.target_pose.pose = self.pose_seq[self.goal_cnt]
        rospy.loginfo("Sending goal pose "+str(self.goal_cnt+1)+" to Action Server")
        rospy.loginfo(str(self.pose_seq[self.goal_cnt]))
        self.client.send_goal(goal, self.done_cb, self.active_cb, self.feedback_cb)
        rospy.spin()

if __name__ == '__main__':
    try:
        MoveBaseSquare()
    except rospy.ROSInterruptException:
        rospy.loginfo("Navigation finished.")